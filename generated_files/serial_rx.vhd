-- File: serial_rx.vhd
-- Generated by MyHDL 0.8
-- Date: Thu Aug 21 10:54:44 2014


library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use std.textio.all;

use work.pck_myhdl_08.all;

entity serial_rx is
    port (
        sysclk: in std_logic;
        reset_n: in std_logic;
        half_baud_rate_tick_i: in std_logic;
        baud_rate_tick_i: in std_logic;
        recieve_i: in std_logic;
        data_o: out unsigned(7 downto 0);
        ready_o: out std_logic
    );
end entity serial_rx;
-- Serial
-- This module implements a reciever serial interface
-- 
-- Ports:
-- -----
-- sysclk: sysclk input
-- reset_n: reset input
-- half_baud_rate_tick_i: half baud rate tick
-- baud_rate_tick_i: the baud rate
-- n_stop_bits_i: number of stop bits
-- recieve_i: rx
-- data_o: the data output in 1 byte
-- ready_o: indicates data_o is valid
-- -----

architecture MyHDL of serial_rx is


constant n_stop_bits_i: integer := 2;
constant END_OF_BYTE: integer := 7;


type t_enum_t_State_1 is (
    ST_WAIT_START_BIT,
    ST_GET_DATA_BITS,
    ST_GET_STOP_BITS
);

signal data_reg: unsigned(7 downto 0);
signal count_8_bits_reg: unsigned(2 downto 0);
signal data: unsigned(7 downto 0);
signal count_8_bits: unsigned(2 downto 0);
signal ready: std_logic;
signal state: t_enum_t_State_1;
signal count_stop_bits_reg: unsigned(2 downto 0);
signal count_stop_bits: unsigned(2 downto 0);
signal state_reg: t_enum_t_State_1;
signal ready_reg: std_logic;

begin





data_o <= data_reg;
ready_o <= ready_reg;


SERIAL_RX_SEQUENTIAL_PROCESS: process (sysclk, reset_n) is
begin
    if (reset_n = '0') then
        count_8_bits_reg <= to_unsigned(0, 3);
        count_stop_bits_reg <= to_unsigned(0, 3);
        ready_reg <= '0';
        state_reg <= ST_WAIT_START_BIT;
        data_reg <= to_unsigned(0, 8);
    elsif rising_edge(sysclk) then
        state_reg <= state;
        data_reg <= data;
        ready_reg <= ready;
        count_8_bits_reg <= count_8_bits;
        count_stop_bits_reg <= count_stop_bits;
    end if;
end process SERIAL_RX_SEQUENTIAL_PROCESS;


SERIAL_RX_COMBINATIONAL_PROCESS: process (count_8_bits_reg, recieve_i, data_reg, baud_rate_tick_i, count_stop_bits_reg, state_reg, ready_reg) is
begin
    state <= state_reg;
    data <= data_reg;
    ready <= ready_reg;
    count_8_bits <= count_8_bits_reg;
    count_stop_bits <= count_stop_bits_reg;
    case state_reg is
        when ST_WAIT_START_BIT =>
            ready <= '0';
            if (baud_rate_tick_i = '1') then
                if (recieve_i = '0') then
                    state <= ST_GET_DATA_BITS;
                end if;
            end if;
        when ST_GET_DATA_BITS =>
            if (baud_rate_tick_i = '1') then
                data(to_integer(count_8_bits_reg)) <= recieve_i;
                if (count_8_bits_reg = END_OF_BYTE) then
                    count_8_bits <= to_unsigned(0, 3);
                    state <= ST_GET_STOP_BITS;
                else
                    count_8_bits <= (count_8_bits_reg + 1);
                    state <= ST_GET_DATA_BITS;
                end if;
            end if;
        when ST_GET_STOP_BITS =>
            if (baud_rate_tick_i = '1') then
                if (signed(resize(count_stop_bits_reg, 4)) = (n_stop_bits_i - 1)) then
                    count_stop_bits <= to_unsigned(0, 3);
                    ready <= '1';
                    state <= ST_WAIT_START_BIT;
                else
                    count_stop_bits <= (count_stop_bits_reg + 1);
                end if;
            end if;
        when others =>
            assert False report "End of Simulation" severity Failure;
    end case;
end process SERIAL_RX_COMBINATIONAL_PROCESS;

end architecture MyHDL;
