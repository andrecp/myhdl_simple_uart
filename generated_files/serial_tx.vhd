-- File: serial_tx.vhd
-- Generated by MyHDL 0.8
-- Date: Thu Aug 21 10:54:44 2014


library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use std.textio.all;

use work.pck_myhdl_08.all;

entity serial_tx is
    port (
        sysclk: in std_logic;
        reset_n: in std_logic;
        start_i: in std_logic;
        data_i: in unsigned(7 downto 0);
        baud_rate_tick_i: in std_logic;
        transmit_o: out std_logic
    );
end entity serial_tx;
-- Serial
-- This module implements a transmitter serial interface
-- 
-- Ports:
-- -----
-- sysclk: sysclk input
-- reset_n: reset input
-- baud_rate_tick_i: the baud rate
-- start_i: start sending data
-- data_i: the data to send
-- n_stop_bits_i: number of stop bits
-- transmit_o: data output
-- -----

architecture MyHDL of serial_tx is


constant n_stop_bits_i: integer := 2;
constant END_OF_BYTE: integer := 7;


type t_enum_t_State_1 is (
    ST_WAIT_START,
    ST_SEND_START_BIT,
    ST_SEND_DATA,
    ST_SEND_STOP_BIT
);

signal transmit_reg: std_logic;
signal count_8_bits: unsigned(2 downto 0);
signal count_8_bits_reg: unsigned(2 downto 0);
signal state: t_enum_t_State_1;
signal transmit: std_logic;
signal count_stop_bits_reg: unsigned(2 downto 0);
signal count_stop_bits: unsigned(2 downto 0);
signal state_reg: t_enum_t_State_1;

begin





transmit_o <= transmit_reg;


SERIAL_TX_SEQUENTIAL_PROCESS: process (sysclk, reset_n) is
begin
    if (reset_n = '0') then
        count_8_bits_reg <= to_unsigned(0, 3);
        count_stop_bits_reg <= to_unsigned(0, 3);
        transmit_reg <= '0';
        state_reg <= ST_WAIT_START;
    elsif rising_edge(sysclk) then
        state_reg <= state;
        transmit_reg <= transmit;
        count_8_bits_reg <= count_8_bits;
        count_stop_bits_reg <= count_stop_bits;
    end if;
end process SERIAL_TX_SEQUENTIAL_PROCESS;


SERIAL_TX_COMBINATIONAL_PROCESS: process (transmit_reg, start_i, count_8_bits_reg, data_i, baud_rate_tick_i, count_stop_bits_reg, state_reg) is
begin
    state <= state_reg;
    transmit <= transmit_reg;
    count_8_bits <= count_8_bits_reg;
    count_stop_bits <= count_stop_bits_reg;
    case state_reg is
        when ST_WAIT_START =>
            transmit <= '1';
            if (start_i = '1') then
                state <= ST_SEND_START_BIT;
            end if;
        when ST_SEND_START_BIT =>
            transmit <= '0';
            if (baud_rate_tick_i = '1') then
                state <= ST_SEND_DATA;
            end if;
        when ST_SEND_DATA =>
            transmit <= data_i(to_integer(count_8_bits_reg));
            if (baud_rate_tick_i = '1') then
                if (count_8_bits_reg = END_OF_BYTE) then
                    count_8_bits <= to_unsigned(0, 3);
                    state <= ST_SEND_STOP_BIT;
                else
                    count_8_bits <= (count_8_bits_reg + 1);
                    state <= ST_SEND_DATA;
                end if;
            end if;
        when ST_SEND_STOP_BIT =>
            transmit <= '1';
            if (baud_rate_tick_i = '1') then
                if (signed(resize(count_stop_bits_reg, 4)) = (n_stop_bits_i - 1)) then
                    count_stop_bits <= to_unsigned(0, 3);
                    state <= ST_WAIT_START;
                else
                    count_stop_bits <= (count_stop_bits_reg + 1);
                end if;
            end if;
        when others =>
            assert False report "End of Simulation" severity Failure;
    end case;
end process SERIAL_TX_COMBINATIONAL_PROCESS;

end architecture MyHDL;
